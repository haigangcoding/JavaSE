public class BiteOperators21 {
    public static void main(String[] args) {
//        int a = 9, b = 3;
        // 按 位与 实际上 就是让两个数 每一位都进行比较
        // 如果这一位两个数都是 1，那么结果就是 1，否则就是 0
        // a = 9 = 1001
        // b = 3 = 0011
        // c = 1 = 0001(因为只有最后一位，两个数都是 1
        // 所以说结果最后一位是 1，其他都是 0)
        //int c = a & b;  // 进行 按位与运算 等于 1


        // 按位或，其实就是只要任意一个为 1 （不能同时为 0）那么结果为 1
        // a = 9 = 1001
        // b = 3 = 0011
        // c = 11 = 1011(只要上下有 一个是 1 或者 都是 1，那么结果 为 1)
        //int c = a | b; // 进行 按位或运算

        // ^ 是 按位异或运算符
        // 异或的意思就是只有两边不相同的情况下，结果才是 1
        // 也就是说一边是 1， 一边是 0
        // a = 9 = 1001
        // b = 3 = 0011
        // c = 10 = 1010
        // (从左往右第二位  第四位要么两个都是 0 要么都是 1，所以说结果 为 0)
        //int c = a ^ b;  // 等于 10


        // 按位取反操作跟前面 正负号一样，只操作一个数。
        // 如果这一位是 1，变成 0 如果是 0 变成 1
        // 127 = 01111111
        // -128 = 10000000
//        byte c = ~127;  // 等于 -128

        // 1 = 00000001
        // 4 = 00000100 （左移两位之后， 1 跑到前面去了，尾部使用 0 填充，此时就是 4）
        // byte c = 1 << 2;  // 两个连续的小于符号，表示左移运算

        // 8 = 00001000
        // 2 = 00000010 （右移两位之后， 1 跑到后面去了， 头部使用符号位数字 填充，此时变成 2）
//        byte c = 8 >> 2;

        // -4 = 11111100
        // -2 = 11111110
        // (前面这一长串 1 都被推到后面一位 因为是负数，头部需要使用 符号位数字 来进行填充)
        byte c = -4 >> 1;
        System.out.println(c);

        // 左移操作 << 高位直接 丢弃，地位补 0
        // 右移操作 >> 低位直接丢弃， 符号位是什么高位补什么
    }
}
